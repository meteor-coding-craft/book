---
description: >-
  이번 장에서는 미티어의 리액티비티를 이해해보자. 리액티비티는 미티어의 근간을 구성하는 개념이지만, 기존 프로그래밍 방식과 달라서 혼자
  학습하며 개념을 이해하기에 다소 생소하게 느낄 수 있다. 하지만 리액티비티가 그다지 새로운 개념도 아니니 부담을 가질 필요는 없다.
---

# 29장 리액티비티

 좀 더 쉽게 리액티비티 개념을 이해하기 위해 다음 그림을 보자. 그림에서는 불을 감지하는 센서가 장작의 불을 감지하여 물을 불 위에 뿌리기까지의 과정을 도식화했다.

![](.gitbook/assets/image%20%2812%29.png)

그림처럼 누군가 나무에 불을 붙였다면 당연히 나무는 불탄다. 이때 나무가 불타는 것을 센서가 감지하여 물을 뿌리게 된다. 이것은 우리 주위에 흔하게 있는 화재 감지 센서 이야기다. 너무도 당연한 이야기이다. 하지만 이것을 프로그래밍 방식으로 적용한다면 어떨까? 만약 그런 방식이 있다면 머라고 할까? 그림에서처럼 변경이 일어나는 무언가를 감지하여 그에 따른 동작을 일으키는 방식의 프로그래밍을 "리액티브 프로그래밍" 또는 "리액티브 프로그램"이라고 한다.

미티어에서는 화재 감지 센서를 "**리액티브 컴퓨테이션**"이라고 하고 센서가 감지하는 대상인 장작을 "**리액티브 데이터 소스**"라고 한다. 다시 말해서 리액티브 데이터 소스\(장작\)가 외적인 요소\(점화\)로 인해 상태가 변경\(불\)되고, 그 변경\(장작-&gt;불\)을 감지한 리액티브 컴퓨테이션\(센서\)이 임의의 동작\(물 뿌리기\)을 하게 만드는 것이다.

그런데 위와 같은 리액티브 프로그래밍을 우리는 이미 하고 있었다. 놀랍게도 우리가 자주 쓰는 엑셀과 같은 프로그램에서 수십 년 동안 존재해온 프로그래밍 방식이다. 그래서 이번 장에서는 미티어에 존재하는 리액티비티를 이해하기 위해, 역사가 오래된 엑셀의 리액티비티를 먼저 살펴보고 몇 가지 특징을 발견해보자. 그다음 발견해낸 특징, 즉 리액티비티의 특징을 미티어로 똑같이 구현해봄으로써 리액티비티를 완벽하게 이해해보자. 순서는 다음과 같다.

* 리액티비티의 개념과 미티어
* 기본 패키지를 이용한 실습
* 웹 브라우저의 리액티비티
* 서버의 리액티비티

## 29.1 리액티비티의 개념과 미티어

리액티비티 프로그래밍은 미티어를 이루는 개념의 큰 축이지만 아주 오래전부터 우리 주변에 있어온 개념이다. 가장 가까운 예제가 엑셀이다. 엑셀을 언급하기 전에 다음 코드를 잠깐 살펴보자.

```text
A1 = 5
B1 = 8
C1 = A1 + B1    
A1 = 2 

print(C1)
```

print가 값을 출력하는 함수라고 할 때 C1은 몇이 출력될까? 물론 13이 출력될 것이라고 추측된다. 일반 프로그래밍에서 C1은 13이다. 하지만 리액티브 프로그래밍에서 C1은 10이다. C1 = A1 + B1이라고 선언만 하여도 A1이나 B1 값이 바뀌면 그것이 감지되어 C1 값은 자동으로 재계산되어 할당된다.

이것을 엑셀에서 한 번 살펴보자

![&#xADF8;&#xB9BC; 29-2 &#xC5D1;&#xC140;&#xC758; &#xB9AC;&#xC561;&#xD2F0;&#xBE44;&#xD2F0;1](.gitbook/assets/image%20%285%29.png)

그림처럼 작성하고 나서 A1이나 B1의 값을 바꿔보자. C1의 값은 자동으로 변경되는 걸 확인할 수 있다. 우리는 A1이나 B1 셀의 값만 바꾸었을 뿐 C1의 값을 재계산하기 위해 아무것도 하지 않았다.

다시 엑셀로 돌아가 다음 그림을 보자.

![&#xADF8;&#xB9BC; 29-3 &#xC5D1;&#xC140;&#xC758; &#xB9AC;&#xC561;&#xD2F0;&#xBE44;&#xD2F0;2](.gitbook/assets/image%20%2811%29.png)

C1의 값은 "fx=A1+B1"라고 표시되어 있다. 화재를 감지한 뒤 물을 뿌리는 동작을 정의한 것이다. 즉, fx는 A1과 B1을 더하여 C1에 할당하는 "동작"을 정의했다. 그리고 이 동작은 A1과 B1이 변경 될 때마다 엑셀에 의해 자동으로 재호출된다. 이것이 엑셀의 "리액티비티"다.

![&#xADF8;&#xB9BC; 29-4 &#xC5D1;&#xC140;&#xC758; &#xB9AC;&#xC561;&#xD2F0;&#xBE44;&#xD2F0;&#xAC00; &#xB3D9;&#xC791;&#xD558;&#xB294; &#xBC29;&#xC2DD;](.gitbook/assets/image%20%2830%29.png)



미티어에서는 A1, B1처럼 데이터를 포함한 셀을 "리액티브 데이터 소스", 그리고 "A1 + B1"처럼 연산하여 동작하는 것을 "리액티브 컴퓨테이션"이라고 부른다.

![&#xADF8;&#xB9BC; 29-5 &#xB9AC;&#xC561;&#xD2F0;&#xBE0C; &#xB370;&#xC774;&#xD130; &#xC18C;&#xC2A4;&#xC640; &#xB9AC;&#xC561;&#xD2F0;&#xBE0C; &#xCEF4;&#xD4E8;&#xD14C;&#xC774;&#xC158;](.gitbook/assets/image%20%286%29.png)



그리고 리액티브 컴퓨테이션은 또 다른 컴퓨테이션의 소스가 될 수 있다. 다음 그림을 보자.

![&#xADF8;&#xB9BC; 29-6 &#xB9AC;&#xC561;&#xD2F0;&#xBE44;&#xD2F0;&#xC758; &#xC804;&#xC774;](.gitbook/assets/image%20%2814%29.png)

위 그림에서 C1은 "fx = C1 / 2" 안에 C2의 값을 결정하는 함수의 데이터 소스로 사용된다. 이것은 리액티브 컴퓨테이션은 다른 컴퓨테이션의 데이터 소스가 될 수 있음을 의미한다. 게다가 A1, B1의 값이 변경되면 그 이벤트의 감지가 C1을 거쳐 C2까지 자동으로 전달된다. 이것은 미티어도 마찬가지다.

![&#xADF8;&#xB9BC; 29-7 &#xB9AC;&#xC561;&#xD2F0;&#xBE0C; &#xCEF4;&#xD4E8;&#xD14C;&#xC774;&#xC158;&#xC744; &#xB370;&#xC774;&#xD130; &#xC18C;&#xC2A4;&#xB85C; &#xC0AC;&#xC6A9;&#xD560; &#xC218; &#xC788;&#xB2E4;](.gitbook/assets/image%20%2832%29.png)

지금까지 엑셀을 통해 알아본 리액티비티에 대한 성질을 정리하면 이렇다.

1. **리액티비티 정리 1**  리액티브 컴퓨테이션은 함수 구문에 있는 리액티브 데이터 소스\(A1, B2\)의 변화를 감지하여 재실행 된다.  ****
2. **리액티비티 정리 2** 리액티브 컴퓨테이션은 또 다른 리액티브 컴퓨테이션의 데이터 소스가 될 수 있다.  ****
3. **리액티비티 정리 3**  리액티브 데이터 소스의 변화는 이를 감싸고 있는 상위 데이터 컴퓨테이션으로 전이되어 변화가 감지된다.

## 29.2 기본 패키지를 이용한 실습

리액티비티는 변화를 발산하는 "리액티브 데이터 소스", 그리고 이 데이터 소스의 변화를 감지하여 \(재\)실행되는 "리액티브 컴퓨테이션", 이 두 가지 핵심 요소로 구성된다. 이것을 엑셀을 통하여 알아보았다. 그렇다면 미티어는 어떨까? 바로 이전 29.1에서의 리액티비티 정리 1, 2, 3이 미티어에서도 해당하는지 실험해보자.

실험하기 위해서 프로젝트를 생성한다\(이해를 위해서는 직접 해 보는 걸 권하지만, 다른 장에서 참조를 통해 넘어 온 거라면 가볍게 읽고 넘어가도 좋다\).

`콘솔에서 reactivity 프로젝트 생성` : 

```text
~/Projects$ meteor create reactivity
reactivity: created.                          

To run your new app:                          
  cd reactivity                               
meteor

~/Projects$ cd reactivity
~/Projects/reactivity$ meteor run
```

콘솔을 하나 더 열고 미티어에서 리액티브 데이터 리소스를 만들어 주는 reactive-var 패키지를 설치하자.

```text
~/Projects/reactivity$ meteor add reactive-var 

reactive-var: Reactive variable     
~/Projects/reactivity$
```

이제 준비가 다 되었다. 이제부터 코드로 미티어의 리액티비티를 증명해보자!

> **리액티비티 정리 1**  
> 리액티브 컴퓨테이션은 함수 구문에 리액티브 데이터 소스\(A1, B2\)의 변화를 감지하여 재실행된다.

정리 1을 실험해 보기 위해서는 미티어에서 리액티브 데이터 소스 A1, B1을 만들어야 한다. ~/Projects/reactivity/client/main.js 파일 내부의 모든 내용을 지우고 다음과 같이 작성해보자.

`~/Projects/reactivity/client/main.js` : 

```javascript
    A1 = new ReactiveVar(5);
    B1 = new ReactiveVar(8);
    console.log( "A1 : ", A1.get(), ", B1 : ", B1.get() );
```

그리고 ~/Projects/reactivity/client/main.html 파일의 내용을 모두 비우자.

`~/Projects/reactivity/client/main.html` : 

```javascript
<!-- 삭제합니다 -->
```

미티어에서 리액티브 데이터 소스를 만드는 오브젝트인 ReactiveVar 객체를 이용하여 A1, B1이라는 리액티브 데이터 소스를 5, 8이라는 초깃값을 주어 생성했다. ReactiveVar 객체의 get 메서드를 이용해 콘솔에 값을 출력해 보았다. 결과는 다음 그림과 같다.

![&#xADF8;&#xB9BC; 29-8 &#xB9AC;&#xC561;&#xD2F0;&#xBE0C; &#xB370;&#xC774;&#xD130; &#xC18C;&#xC2A4; &#xC0DD;&#xC131; &#xBC0F; &#xCD9C;&#xB825; &#xD14C;&#xC2A4;&#xD2B8;](.gitbook/assets/image%20%2828%29.png)

이제 리액티브 데이터 컴퓨테이션 함수 C1을 다음과 같이 만들자.

`~/Projects/ reactivity/client/main.js` :

```javascript
  ...생략...
  C1 = function(){
        var sum = A1.get() + B1.get();
        console.log( "여기는 C1 함수 fx = A1+B1 => ", sum);
        return sum;
    };
  Tracker.autorun(C1);
```

C1 함수는 엑셀에서처럼 `A1.get() + B1.get();`을 반환하게 작성했다. 하지만 미티어에서 리액티브 데이터 소스를 함수 내에서 사용하는 것만으로 리액티브 컴퓨테이션 함수가 되는 것은 아니다. `Tracker` 객체의 `autorun` 메서드를 이용해 리액티브 컴퓨테이션으로 만들어 주어야 한다.

{% hint style="info" %}
Tracker 객체에는 autorun 메서드가 있으며 우리가 작성한 함수를 사용자 리액티브 컴퓨테이션 함수로 만들어 준다. 구 버전에서는 Deps 객체였으나 Tracker로 이름이 변경되었다.
{% endhint %}

이제 선언했으니 A1.set\(값\) 형태로 콘솔에서 변경시켜서 리액티브 컴퓨테이션 C1이 자동으로 호출되는지를 확인해보자. 웹 브라우저 개발자 도구의 콘솔에서 다음처럼 입력해보자.

```javascript
> A1.set(12);
```

또한, B1 값도 set을 이용하여 22로 변경해보자.

```javascript
> B1.set(22);
```

컴퓨테이션의 동작을 그림에서 확인해보자.

![&#xADF8;&#xB9BC; 29-9 &#xCEF4;&#xD4E8;&#xD14C;&#xC774;&#xC158; &#xB3D9;&#xC791; &#xD655;&#xC778;1](.gitbook/assets/image%20%2818%29.png)

C1 함수를 A1과 B1의 합을 구하는 함수로 선언만했는데, A1, B1 값이 변경된 것을 감지하여 C1 함수가 자동으로 호출되었다\(**리액티비티 정리1**\).

> **리액티비티 정리 2**  
> 리액티브 컴퓨테이션은 또 다른 리액티브 컴퓨테이션의 데이터 소스가 될 수 있다.

**리액티비티 정리 2**를 실험해보자. 실험을 위해 기존 코드에 다음과 같이 C2 코드를 추가해보자.

`~/Projects/ reactivity/client/main.js` : 

```javascript
    ...생략...
    C2 = function(){
        var avg = C1() / 2;
        console.log( "여기는 C2 함수 fx = C1/2 =>", avg);
        return avg ;
    };
    Tracker.autorun(C2);
```

그리고 콘솔의 지난 로그를 삭제 후 다음처럼 입력해보자\(Clear console 버튼을 클릭하거나 콘솔에서 Ctrl+L을 누르면 로그가 삭제된다\).

```javascript
> A1.set(12);
```

결과가 다음 그림처럼 나온다. 그림을 살펴보자.

![&#xADF8;&#xB9BC; 29-10 &#xCEF4;&#xD4E8;&#xD14C;&#xC774;&#xC158; &#xB3D9;&#xC791; &#xD655;&#xC778;2](.gitbook/assets/image%20%2824%29.png)

첫 번째로 콘솔 로그를 지웠다. 그 뒤 A1 값을 변경함으로 인해서 C1, C2 함수가 자동으로 호출되었다. 

이는 A1이 변경됨을 감지한 C1\(리액티브 컴퓨테이션\)함수가 자동으로 재계산되었고, C1이 자동으로 재계산되어 반환값이 변경됨을 감지한 C2 함수가 자동으로 호출되었다. 이것은 리액티비티 정리 2, 3이 동작한 것임을 알 수 있다.  과정에서 C1함수는 2번 호출 되었다. 첫번째로는 A1이 변경됨으로 인하여, 또 한번은 C1이 변경됨을 감지한 C2함수의 내용 안에 C1함수 호출이 포함되어 있어 총 2번 호출되었다.

미티어도 엑셀과 같은 리액티비티의 세 가지 특징을 갖고 있음을 알 수 있고, ReactiveVar와 Tracker를 이용하여 사용자가 직접 리액티브 데이터 소스와 리액티브 컴퓨테이션 함수를 작성할 수 있음을 알 수 있다.

## 29.3 웹 브라우저에서 리액티비티

지금까지 리액티비티의 원리에 대하여 직접 구현하면서 알아보았다. 그리고 스페이스바에서 어떻게 리액티비티가 동작하는지 "26.6 스페이스바의 리액티비티"에서도 알아보았다. 이번에는 리액티비티가 클라이언트에서 어떻게 동작하는지 좀 더 구체적으로 알아보자. 우선 다음 그림을 살펴보자.

![&#xADF8;&#xB9BC; 29-11 &#xD074;&#xB77C;&#xC774;&#xC5B8;&#xD2B8;&#xC5D0;&#xC11C;&#xC758; &#xB9AC;&#xC561;&#xD2F0;&#xBE44;](.gitbook/assets/image%20%282%29.png)

그림에서 클라이언트에서 리액티비티에 의한 DOM의 변경 동작 순서는 다음과 같다.

* 발행/구독에 따라 미니몽고의 데이터가 변화된다.
* 변화된 미니몽고의 데이터가 감지되어 템플릿 헬퍼가 DOM을 업데이트한다.
* 실제로 DOM이 변경된 부분만 업데이트된다.

미티어의 발행/구독 코드에 따라 서버에서 추가, 변경, 삭제된 데이터가 미니몽고에 실시간으로 반영된다. 템플릿 헬퍼는 이 변화를 감지하여 DOM을 업데이트한다. 이때 DOM 전체를 업데이트하지 않고 변화된 부분만 업데이트한다. 주소록의 경우 name 필드의 값이 바뀌었으면 name을 표현하는 td의 HTML 코드만 업데이트한다. 해당 리스트나 tr 요소 전체를 업데이트하지 않는다.

3장 주소록 만들기의 예제 코드에서 DOM 변경 동작 리액티비티 코드는 다음과 같다.

![&#xADF8;&#xB9BC; 29-12 &#xD074;&#xB77C;&#xC774;&#xC5B8;&#xD2B8;&#xC5D0;&#xC11C;&#xC758; &#xB9AC;&#xC561;&#xD2F0;&#xBE44;&#xD2F0; &#xCF54;&#xB4DC;](.gitbook/assets/image%20%289%29.png)

일반적인 프로그램 방식처럼 사용자 이벤트 발생 시 서버에 데이터를 요청하고, 서버에서 데이터를 반환 받아 DOM을 업데이트하는 것과 달리, 미티어 클라이언트의 리액티비티는 미니몽고가 변경되면 해당 시점에 DOM을 업데이트하므로 실시간 프로그램을 작성하기가 쉽다. 또한, 미니몽고는 발행/구독에 의해 서버 데이터의 변경 사항을 지속적으로 반영하므로 몽고DB에서 DOM까지 실시간으로 반영되는 프로그램을 작성하기가 쉬워진다. 다음은 서버가 어떻게 몽고DB의 변화를 감지하는지 알아보자.

## 29.4 서버의 리액티비티

미티어 서버에서 리액티비티의 핵심은 몽고DB 데이터 변화에 대한 감지다. 몽고DB\(마스터 또는 프라이머리\)는 데이터에 변화가 있을 때마다 오퍼레이션 로그를 남기고 복제 서버\(슬레이브 또는 세컨더리\)들이 로그를 읽어 스스로 반영한다. 이를 간단하게 도식화하면 다음과 같다.

![&#xADF8;&#xB9BC; 29-13 &#xBABD;&#xACE0;DB&#xC758; &#xBCF5;&#xC81C;\(&#xB808;&#xD50C;&#xB9AC;&#xCE74; &#xC138;&#xD2B8;\) &#xC6D0;&#xB9AC;](.gitbook/assets/image%20%2819%29.png)

insert나 update 또는 remove에 의한 데이터 변경이 있을 때마다 몽고DB 프라이머리는 자신의 local 데이터베이스의 oplog.rs라는 컬렉션에 모든 로그를 기록한다. 만약 한 건의 update 요청에 의해 여러 건에 영향을 미쳤다면 친절하게도 모든 영향 받은 데이터를 로그로 남긴다. 이를 통해 세컨더리 몽고DB들은 서버와 똑같은 데이터를 가질 수 있게 된다.

이런 몽고DB의 복제 원리를 미티어에서 잘 이용하고 있다. 그림으로 그려 보면 다음과 같다.

![&#xADF8;&#xB9BC; 29-14 &#xBBF8;&#xD2F0;&#xC5B4;&#xC758; oplog &#xC2A4;&#xCE90;&#xB2DD;](.gitbook/assets/image%20%2826%29.png)

미티어 서버는 몽고DB의 슬레이브와 같이 oplog를 스캐닝하고 있다가 변화가 감지되면 구독 요청이 들어온, 현재 연결된 모든 웹 브라우저에 변화된 데이터를 보내준다. 따라서 웹 브라우저에서도 미니몽고에 반영할 수 있게 되는 것이다. 이제 서버의 리액티비티와 브라우저에서의 리액티비티를 하나로 연결하여 데이터 흐름을 보면 다음 그림과 같다.

![&#xADF8;&#xB9BC; 29-15 &#xBBF8;&#xD2F0;&#xC5B4;&#xC758; &#xB9AC;&#xC561;&#xD2F0;&#xBE44;&#xD2F0;](.gitbook/assets/image%20%2816%29.png)

1. 몽고DB에서 insert, update, remove 등으로 인해 변화가 일어난다.
2. 몽고DB는 oplog에 변화에 대한 모든 로그를 남긴다.
3. 미티어 서버는 oplog의 변화를 감지한다.
4. 변경된 데이터를 발행/구독으로 연결된 클라이언트로 전송한다.
5. 미티어 서버에서 구독하여 변경된 정보를 미니몽고에 반영한다.
6. 템플릿 헬퍼는 미니몽고 변화를 감지하고 변경된 데이터를 DOM에 제공한다.
7. 변경된 데이터로 해당 DOM을 업데이트한다.

이렇게 해서 몽고DB에서 변경된 데이터는 클라이언트까지 실시간으로 반영될 수 있다. 이 구간은 모두 리액티비티의 원리로 설명할 수 있다.

## 29.5 기본 리액티브 데이터 소스와 컴퓨테이션들 살펴 보기

미니몽고의 데이터, 정확히 말하면 미니몽고의 find 문장이 반환하는 커서는 가장 중요한 "**리액티브 데이터 소스**"이고 Template의 helpers 맵 안에 있는 함수들은 이를 감지하는 "**리액티브 컴퓨테이션**" 함수다. 이외에 미티어가 기본으로 제공하는 리액티브 데이터 소스와 컴퓨테이션에 대하여 몇 가지 살펴보자.

**리액티브 데이터 소스 :** 

* Session – 미티어의 세션이다. 세션은 핫 코드 푸시\(실시간 소스 업데이트\)에도 값이 유지되는 특성이 있다.
* Meteor.status – 현재 클라이언트\(웹 브라우저\)서 서버와 접속 상태를 알 수 있는 데이터 소스다.
* 구독 함수\(subscribe\)가 반환하는 핸들의 ready\(\) – 현재 구독이 정상인지 여부를 알 수 있다.
* Meteor.user – 로그인된 사용자, 로그아웃될 경우 변경된다.
* Mestor.userId – 로그인된 사용자의 아이디, 로그아웃될 경우 변경된다.
* Meteor.logingIn – 현재 로그인 중인지를 나타내는 값으로 로그인이 완료되면 변경된다. 로그인 중인 상태를 표시하고자 할 때 유용하다.

**리액티브 컴퓨테이션 :**

* Tracker.autorun – 인자로 넘어가는 콜백 함수를 컴퓨테이션 함수로 만들어준다. 반환된 구독 핸들을 이용해 변화 감지를 제어할 수 있다. 가령 구독 핸들의 stop 함수를 호출하면 구독을 즉시 중지한다.
* Template.autorun – Tracker.autorun과 같으나 Template의 onDestroyed 함수가 호출되면 자동으로 구독을 정지하므로 템플릿 인스턴스의 onCreated에서 안에서 데이터를 구독할 때는 이 함수를 이용하는 게 좋다







